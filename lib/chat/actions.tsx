import 'server-only'

import {
  createAI,
  createStreamableUI,
  getMutableAIState,
  getAIState,
  render,
  createStreamableValue
} from 'ai/rsc'
import OpenAI from 'openai'

import {
  spinner,
  BotCard,
  BotMessage,
  SystemMessage
} from '@/components/stocks'

import { z } from 'zod'

import { Events } from '@/components/stocks/event'
import { Stocks } from '@/components/stocks/stocks'
import { loadVideosWithCaptions } from '../api/loadVideosWithCaptions';
import { Videos } from '@/components/videos/videos'
import {
  formatNumber,
  runAsyncFnWithoutBlocking,
  sleep,
  nanoid
} from '@/lib/utils'
import { saveChat } from '@/app/actions'
import { SpinnerMessage, UserMessage } from '@/components/stocks/message'
import { Chat } from '@/lib/types'
import { auth } from '@/auth'


const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || ''
})


async function submitUserMessage(content: string) {
  'use server'

  const aiState = getMutableAIState<typeof AI>()

  aiState.update({
    ...aiState.get(),
    messages: [
      ...aiState.get().messages,
      {
        id: nanoid(),
        role: 'user',
        content
      }
    ]
  })

  let textStream: undefined | ReturnType<typeof createStreamableValue<string>>
  let textNode: undefined | React.ReactNode

  const ui = render({
    model: 'gpt-3.5-turbo',
    provider: openai,
    initial: <SpinnerMessage />,
    messages: [
      {
        role: 'system',
        content: `\
You are Khilo.         
You are a video MVP important moments search conversation bot and you can help users to find most important moments withing the video.
You and the user can discuss about hobbies and you can suggest user to search for a videos based on generated by you search term.
Messages inside [] means that it's a UI element or a user event. For example:
- "[Video ID moment play from start to the end]" means that an interface of video moment shown to the user.

You have to have a small talk with the user and provide a best search term key. to be as spacific as possible. 

Suggest user video moments based on a term, call \`provide_video_captions_to_ai\` to get video_id and timed captions in xml format.

Suggest the best moments and call function \`show_video_moments\` to show a list of video moments.

Besides that, you can also chat with users in friendly manner and do some clarifications if needed.`
      },
      ...aiState.get().messages.map((message: any) => ({
        role: message.role,
        content: message.content,
        name: message.name
      }))
    ],
    text: ({ content, done, delta }) => {
      if (!textStream) {
        textStream = createStreamableValue('')
        textNode = <BotMessage content={textStream.value} />
      }

      if (done) {
        textStream.done()
        aiState.done({
          ...aiState.get(),
          messages: [
            ...aiState.get().messages,
            {
              id: nanoid(),
              role: 'assistant',
              content
            }
          ]
        })
      } else {
        textStream.update(delta)
      }

      return textNode
    },
    functions: {
      provide_video_captions_to_ai: {
        description: 'API to get 5 videos with captions for futher analysis based on captions',
        parameters: z.object({
          searchKey: z
            .string()
            .describe(
              'The search term to search a video on youtube'
            )
        }),
        render: async function* ({ searchKey }) {
          yield (
            <BotCard>
              <div>`I am presenting videos`{ searchKey }</div>
            </BotCard>
          )
          
          
          await sleep(1000)
          
          const videos = await loadVideosWithCaptions(searchKey);
          
          aiState.done({
            ...aiState.get(),
            messages: [
              ...aiState.get().messages,
              {
                id: nanoid(),
                role: 'function',
                name: 'provide_video_captions_to_ai',
                content: JSON.stringify(videos)
              }
            ]
          })

          return (
            <BotCard>
              <div>
                Video moments comming soon..... 
              </div>
            </BotCard>
          )
        }
      },
      show_video_moments: {
        description: `Get the video slices. 
                      Limit to 5 best. 
                      Use this to show the best moments to the user. 
                      Format response as link (<a href://videoid?from=-here comes slice start time- & to=-here comes slice end time->)`,
        parameters: z.object({
          videoSlice: z
            .array(z.string())
            .describe(
              'Array of the best video moment links'
            )
        }),
        render: async function* ({ videoSlice }) {
          yield (
            <BotCard>
              <div>
                just before presenting results
              </div>
            </BotCard>
          )
          
          await sleep(1000)
          aiState.done({
            ...aiState.get(),
            messages: [
              ...aiState.get().messages,
              {
                id: nanoid(),
                role: 'function',
                name: 'videos_best_matches',
                content: JSON.stringify(videoSlice)
              }
            ]
          })

          return (
            <BotCard>
              <div>
                {videoSlice.map((slice, index) => (
                  <p>Video Moment {index + 1} {slice}</p>
                ))}
              </div>
            </BotCard>
          )
        }
      }
    }
  })

  return {
    id: nanoid(),
    display: ui
  }
}

export type Message = {
  role: 'user' | 'assistant' | 'system' | 'function' | 'data' | 'tool'
  content: string
  id?: string
  name?: string
}

export type AIState = {
  chatId: string
  messages: {
    role: 'user' | 'assistant' | 'system' | 'function' | 'data' | 'tool'
    content: string
    id: string
    name?: string
  }[]
}

export type UIState = {
  id: string
  display: React.ReactNode
}[]

export const AI = createAI<AIState, UIState>({
  actions: {
    submitUserMessage
  },
  initialUIState: [],
  initialAIState: { chatId: nanoid(), messages: [] },
  unstable_onGetUIState: async () => {
    'use server'

    const session = await auth()

    if (session && session.user) {
      const aiState = getAIState()

      if (aiState) {
        const uiState = getUIStateFromAIState(aiState)
        return uiState
      }
    } else {
      return
    }
  },
  unstable_onSetAIState: async ({ state }) => {
    'use server'

    const session = await auth()

    if (session && session.user) {
      const { chatId, messages } = state

      const createdAt = new Date()
      const userId = session.user.id as string
      const path = `/chat/${chatId}`
      const title = messages[0].content.substring(0, 100)

      const chat: Chat = {
        id: chatId,
        title,
        userId,
        createdAt,
        messages,
        path
      }

      await saveChat(chat)
    } else {
      return
    }
  }
})

export const getUIStateFromAIState = (aiState: Chat) => {
  return aiState.messages
    .filter(message => message.role !== 'system')
    .map((message, index) => ({
      id: `${aiState.chatId}-${index}`,
      display:
        message.role === 'function' ? (
          message.name === 'listStocks' ? (
            <BotCard>
              <Stocks props={JSON.parse(message.content)} />
            </BotCard>
          ) : message.name === 'showStockPrice' ? (
            <BotCard>
              <div>log1</div>
            </BotCard>
          ) : message.name === 'showStockPurchase' ? (
            <BotCard>
              <div>log1</div>
            </BotCard>
          ) : message.name === 'getEvents' ? (
            <BotCard>
              <Events props={JSON.parse(message.content)} />
            </BotCard>
          ) : null
        ) : message.role === 'user' ? (
          <UserMessage>{message.content}</UserMessage>
        ) : (
          <BotMessage content={message.content} />
        )
    }))
}
